from __future__ import annotations

import argparse
import json
import os
from pathlib import Path
from typing import Dict, List, Tuple

from dsl.parser import parse_lines
from dsl.ast import Rule

from compiler.base import Capability
from compiler.surge import compile_surge
from compiler.quantumultx import compile_quantumultx
from compiler.clash import compile_clash
from compiler.singbox import compile_singbox
from compiler.v2rayn import compile_v2rayn


ROOT = Path(__file__).resolve().parent
RULES_DIR = ROOT / "rules"
DIST_DIR = ROOT / "dist"
CAP_PATH = ROOT / "capabilities.json"


POLICY_FILES = [
    ("DIRECT", "DIRECT.list"),
    ("PROXY", "PROXY.list"),
    ("REJECT", "REJECT.list"),
    ("PROXY_US", "PROXY_US.list"),
    ("PROXY_HK", "PROXY_HK.list"),
    ("FINAL", "FINAL.list"),
]


def load_capabilities() -> Dict[str, Capability]:
    data = json.loads(CAP_PATH.read_text(encoding="utf-8"))
    return {k: Capability(k, v) for k, v in data.items()}


def load_rules() -> List[Tuple[str, List[Rule]]]:
    out: List[Tuple[str, List[Rule]]] = []
    for policy, fname in POLICY_FILES:
        fp = RULES_DIR / fname
        if not fp.exists():
            # allow missing files
            continue
        parsed = parse_lines(fp.read_text(encoding="utf-8"))
        rules: List[Rule] = []
        for pl in parsed:
            if pl.error:
                raise RuntimeError(f"Parse error in {fp}: {pl.raw}\nReason: {pl.error}")
            if pl.rule is None:
                continue
            rules.append(pl.rule)
        out.append((policy, rules))
    return out


def ensure_dirs():
    DIST_DIR.mkdir(parents=True, exist_ok=True)


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--base-raw-url", default="", help="Base raw URL of your GitHub repo, e.g. https://raw.githubusercontent.com/<user>/<repo>/main/rulelist")
    ap.add_argument("--final-policy", default="PROXY", help="If FINAL.list missing FINAL, force this policy for fallback")
    args = ap.parse_args()

    ensure_dirs()
    caps = load_capabilities()
    rules_by_policy = load_rules()

    header = "Generated by rulelist/build.py"

    # Surge
    surge_res = compile_surge(rules_by_policy, caps["surge"], header)
    (DIST_DIR / "surge.conf").write_text(surge_res.text, encoding="utf-8")

    # Loon/Stash: for baseline, reuse Surge output (basic rules compatible in many cases)
    # You can later add dedicated loon/stash compilers if you want strict syntax control.
    (DIST_DIR / "loon.conf").write_text(surge_res.text, encoding="utf-8")
    (DIST_DIR / "stash.conf").write_text(surge_res.text, encoding="utf-8")

    # Quantumult X
    qx_res = compile_quantumultx(rules_by_policy, caps["quantumultx"], header)
    (DIST_DIR / "quantumultx.conf").write_text(qx_res.text, encoding="utf-8")

    # Clash/mihomo
    if not args.base_raw_url:
        # still generate, but URLs will be empty -> user must fill
        base_raw_url = "https://raw.githubusercontent.com/USER/REPO/main/rulelist"
    else:
        base_raw_url = args.base_raw_url.rstrip("/")
    clash_res = compile_clash(rules_by_policy, caps["clash"], header, base_raw_url)
    (DIST_DIR / "clash.yaml").write_text(clash_res.text, encoding="utf-8")

    # sing-box
    sb_res = compile_singbox(rules_by_policy, caps["singbox"], header)
    (DIST_DIR / "sing-box.json").write_text(sb_res.text, encoding="utf-8")

    # v2rayN / v2ray routing json
    v2n_res = compile_v2rayn(rules_by_policy, caps["v2rayn"], header)
    (DIST_DIR / "v2rayn.json").write_text(v2n_res.text, encoding="utf-8")

    # Write warnings report
    report_lines: List[str] = []
    def dump(name: str, warns):
        if not warns:
            report_lines.append(f"{name}: no warnings")
            return
        report_lines.append(f"{name}: {len(warns)} warnings")
        for w in warns:
            report_lines.append(f"  - [{w.file}] {w.reason}: {w.line}")

    dump("surge", surge_res.warnings)
    dump("quantumultx", qx_res.warnings)
    dump("clash", clash_res.warnings)
    dump("singbox", sb_res.warnings)
    dump("v2rayn", v2n_res.warnings)

    (DIST_DIR / "build_warnings.txt").write_text("\n".join(report_lines) + "\n", encoding="utf-8")


if __name__ == "__main__":
    main()